<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
  
</head>
<body>
  <!-- 배열과 객체는 기본적으로 다른 변수에 해당 배열과 객체를 값으로 넘겨줬을 때 단순 일반 변수와 다르게 복사가 아닌 참조가 된다  -->
  <script>
    // start with strings, numbers and booleans
    let age = 100;
    let age2 = age;
    console.log("1-1 >> ", age, age2);
    age = 200;
    console.log("1-1 >> ", age, age2);
    
    let name = 'sop';
    let name2 = name;
    console.log("1-2 >> ", name, name2);
    name = "sophia";
    console.log("1-2 >> ", name, name2);
    
    // Let's say we have an array
    const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

    // and we want to make a copy of it.
    //const team = players;
    //console.log("2-1 >>> ", players, team);

    // reference back to original 
    // player 배열의 4 번째 값도 변경된다 
    //team[3] = 'Lux';

    //console.log("2-1 updated >>> ", players, team);
    
    // You might think we can just do something like this:

     
    // however what happens when we update that array?

    // now here is the problem!

    // oh no - we have edited the original array too!

    // Why? It's because that is an array reference, not an array copy. They both point to the same array!

    // So, how do we fix this? We take a copy instead!
    // if you push nothing in slice() it would copy of the array to the variable;
    // 1. using slice()
    const team2 = players.slice();
    console.log("2-2 copy of array", players, team2);
    // => now team2 is a copy of players array so that even if i update team2 array, it doesnt effect to players array 
    team2[3] = 'Lux';
    console.log("2-2 copy of array update", players, team2);

    // one way

    // or create a new array and concat the old one in

    // 2. using concat()
    // [] 빈 배열
    // concat 메소드로 players 배열 내의 모든 값들을 하나씩 빈 배열에 복사해 주고 team3에 해당 [] 배열을 넘겨준다
    const team3 = [].concat(players);
    team3[3] = "using concat()";
    console.log("concat >>>", players, team3);
    // or use the new ES6 Spread 
    const team4 = [...players];  
    team4[3] = "what the heck?";
    console.log("spread >>>", players, team4);

    const team5 = Array.from(players);
    team5[3] = "lalala";
    console.log("array from >>", players, team5);
    // now when we update it, the original one isn't changed

    // The same thing goes for objects, let's say we have a person object

    // with Objects
    const person = {
      name: 'Wes Bos',
      age: 80
    };

    // and think we make a copy:
    // => nope that would be a reference
    // const captain = person;
    //captain.number = 99;
    
    // how do we take a copy instead?
    // 객체 복사하기
    // Object.assign(빈객체, 복사하고 싶은 객체, 추가하고자 하는 속성과 값 or 복사하고자 하는 속성과 값 );
    const cap2 = Object.assign({}, person, { number: 99, age: 12 });

    // We will hopefully soon see the object ...spread
    // spread person object to cap3 (copy)
    // but this is a react's grammar
    // const cap3 = {...person};

    // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
    const sop = {
      name: "sophia",
      age: 25,
      social: {
        facebook : "Inactive",
        instagram: "Private",
      }
    }
    console.clear();
    console.log("who are you??", sop);
    // but this is not a deep clone
    // it only copy one level
    // so that social attribute will be a reference
    const dev = Object.assign({}, sop);

    //deep clone - but he doesnt really recommend to use this
    //string으로 바꿨다가 다시 parse하는 방식은, object내에 function이 value로 있을 경우 적합하지 않음
    const dev2 = JSON.parse(JSON.stringify(sop));

    console.log("깊은 복사 >> dev2" , dev2);

    // wes bos 아저씨가 말한 _.cloneDeep
    // lodash는 외부라이브러리
    // nodemoudles

    // function clone 직접 구현 -- 참고
    function clone(source) {
      var target = {};
      for (let i in source) {
        if(source[i] != null && typeof(source[i]) === "object") {
          // 재귀함수
          target[i] = clone(source[i])
        } else {
          target[i] = source[i]
        }
      }
      return target;
    }

const sophia = clone(sop);
console.log('using clone function >>', sop, sophia);

  </script>

</body>
</html>
